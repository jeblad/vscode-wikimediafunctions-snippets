{
	"class.plain 001": {
		"prefix": "class.plain",
		"body": [
			"--- Class for ${1:description}",
			"",
			"-- @var class var for this lib",
			"local ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} = {}",
			"",
			"--- Create a new instance",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}.create( ... )",
			"\tlocal self = setmetatable( {}, ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} )",
			"\tself:_init( ... )",
			"\treturn self",
			"end",
			"",
			"--- Initialize a new instance",
			"-- @private",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:_init( ... ) -- luacheck: no unused args",
			"\tlocal t = { ... }",
			"\t--@todo must probably be completed",
			"\treturn self",
			"end",
			"",
			"$0",
			"",
			"-- Return the final class",
			"return ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}"
		],
		"description": "Plain class structure.\n"
	},
	"class.base 002": {
		"prefix": "class.base",
		"body": [
			"--- Baseclass for ${1:description}",
			"",
			"-- @var class var for this lib",
			"local ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} = {}",
			"",
			"--- Lookup of missing class members",
			"-- @param string used for lookup of member",
			"-- @return any",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:__index( key ) -- luacheck: no self",
			"\treturn ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}[key]",
			"end",
			"",
			"--- Create a new instance",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}.create( ... )",
			"\tlocal self = setmetatable( {}, ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} )",
			"\tself:_init( ... )",
			"\treturn self",
			"end",
			"",
			"--- Initialize a new instance",
			"-- @private",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:_init( ... )",
			"\tlocal t = { ... }",
			"\t--@todo must probably be completed",
			"\treturn self",
			"end",
			"",
			"$0",
			"",
			"-- Return the final class",
			"return ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}"
		],
		"description": "Baseclass structure.\n"
	},
	"class.base 003": {
		"prefix": "class.sub",
		"body": [
			"--- Subclass for ${1:description}",
			"",
			"-- @var class var for base lib",
			"local Base = require '${TM_DIRECTORY}/${2:base-file}'",
			"",
			"-- @var class var for lib",
			"local ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} = {}",
			"",
			"--- Lookup of missing class members",
			"-- @param string used for lookup of member",
			"-- @return any",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:__index( key ) -- luacheck: no self",
			"\treturn ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}[key]",
			"end",
			"",
			"-- @var metatable for the class",
			"setmetatable( ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}, { __index = Base } )",
			"",
			"--- Create a new instance",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}.create( ... )",
			"\tlocal self = setmetatable( {}, ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} )",
			"\tself:_init( ... )",
			"\treturn self",
			"end",
			"",
			"--- Initialize a new instance",
			"-- @private",
			"-- @param vararg",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:_init( ... )",
			"\tlocal t = { ... }",
			"\t--@todo must probably be completed",
			"\treturn self",
			"end",
			"",
			"$0",
			"",
			"-- Return the final class",
			"return ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}"
		],
		"description": "Subclass structure.\n"
	},
	"class.lookup 002": {
		"prefix": "class.lookup",
		"body": [
			"--- Lookup of missing class members",
			"-- @param string used for lookup of member",
			"-- @return any",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:__index( key ) -- luacheck: no self",
			"\t$0",
			"\treturn ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}[key]",
			"end"
		],
		"description": "Lookup missing baseclass members.\n"
	},
	"class.index 003": {
		"prefix": "class.index",
		"body": [
			"--- Lookup of missing class members",
			"-- @param string used for lookup of member",
			"-- @return any",
			"function${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:__index( key ) -- luacheck: no self",
			"\t$0",
			"\treturn ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}[key]",
			"end"
		],
		"description": "Lookup missing instance members.\n"
	},
	"class.create 004": {
		"prefix": "class.create",
		"body": [
			"--- Create a new instance",
			"-- @param vararg",
			"-- @return self",
			"function${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}.create( ... )",
			"\tlocal self = setmetatable( {}, ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g} )",
			"\tself:_init( ... )",
			"\t$0",
			"\treturn self",
			"end"
		],
		"description": "Create class instance.\n"
	},
	"class.init 005": {
		"prefix": "class.init",
		"body": [
			"--- Initialize a new instance",
			"-- @private",
			"-- @param vararg",
			"-- @return self",
			"function${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:_init( ... )",
			"\t$0",
			"\treturn self",
			"end"
		],
		"description": "Initialize class instance.\n"
	},
	"class.accessor 006": {
		"prefix": "class.accessor",
		"body": [
			"--- Access to member $1",
			"-- @param vararg",
			"-- @return any",
			"function${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:${1:name}( ... )",
			"\tif select( '#', ... ) ~= 0 then",
			"\t\tself._$1 = { ... }",
			"\tend",
			"\treturn unpack( self._$1 )",
			"end",
			"$0"
		],
		"description": "Access to instance member.\n"
	},
	"class.set 007": {
		"prefix": "class.set",
		"body": [
			"--- Set member $1",
			"-- @param value",
			"-- @return self",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:set_${1:name}( value )",
			"\tassert( val, 'Failed to provide a value' )",
			"\tself._$1 = value",
			"return self",
			"end",
			"$0"
		],
		"description": "Set instance member value.\n"
	},
	"class.get 008": {
		"prefix": "class.get",
		"body": [
			"--- Get member $1",
			"-- @return any",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:get_${1:name}()",
			"\treturn self._$1",
			"end",
			"$0"
		],
		"description": "Get instance member value.\n"
	},
	"class.is 009": {
		"prefix": "class.is",
		"body": [
			"--- Is instance $1 value",
			"-- @param value",
			"-- @return boolean",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:is_${1:name}( value )",
			"\treturn self._$1 == value",
			"end",
			"$0"
		],
		"description": "Is instance member something.\n"
	},
	"class.has 010": {
		"prefix": "class.has",
		"body": [
			"--- Has instance $1 value",
			"-- @param value",
			"-- @return boolean",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:has_${1:name}( value )",
			"\tfor _,that in ipairs( self._$1 ) do",
			"\t\tif that:is_$1( value ) then",
			"\t\t\treturn true",
			"\t\tend",
			"\tend",
			"\treturn false",
			"end",
			"$0"
		],
		"description": "Has instance member something.\n"
	},
	"class.method 011": {
		"prefix": "class.method",
		"body": [
			"--- Method $1",
			"function ${TM_FILENAME_BASE/[^a-z]*([a-z]+)/${1:/capitalize}/g}:${1:name}()",
			"end",
			"$0"
		],
		"description": "Instance method.\n"
	},
	"frame 001": {
		"prefix": "args",
		"body": [
			"args"
		],
		"description": "Table for arguments passed to the frame."
	},
	"frame 002": {
		"prefix": "frame:callParserFunction( name, args )",
		"body": [
			"frame:callParserFunction( ${1:name}${2:, ${3:args}} )$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 003": {
		"prefix": "frame:callParserFunction( name, ... )",
		"body": [
			"frame:callParserFunction( ${1:name}${2:, ${3:...}} )$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 004": {
		"prefix": "frame:callParserFunction{ name = string, args = table }",
		"body": [
			"frame:callParserFunction{ name = ${1:string}, args = ${2:table} }$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 005": {
		"prefix": "frame:expandTemplate{ name = string, args = table }",
		"body": [
			"frame:expandTemplate{ name = ${1:string}, args = ${2:table} }$0"
		],
		"description": "Transclude a template, returning an appropriate string.\n"
	},
	"frame 006": {
		"prefix": "frame:extensionTag( name, content, args )",
		"body": [
			"frame:extensionTag( ${1:name}${2:[, content]}${3:[, args]} )$0"
		],
		"description": "Call a tag function, returning an appropriate string.\n"
	},
	"frame 007": {
		"prefix": "frame:extensionTag{ name = string, content = string, args =table_or_string }",
		"body": [
			"frame:extensionTag{ name = ${1:string}, args = ${2:string}, args = ${3:table_or_string} }$0"
		],
		"description": "Call a tag function, returning an appropriate string.\n"
	},
	"frame 008": {
		"prefix": "frame:getParent()",
		"body": [
			"frame:getParent()$0"
		],
		"description": "Get the frame of the parent, in the \"invoke\" hierarchy.\n"
	},
	"frame 009": {
		"prefix": "frame:getTitle()",
		"body": [
			"frame:getTitle()$0"
		],
		"description": "Get the title as a string of the frame.\n"
	},
	"frame 010": {
		"prefix": "frame:newChild{ title = title, args = table }",
		"body": [
			"frame:newChild{ title = ${1:title}, args = ${2:table} }$0"
		],
		"description": "Create a new child of the current frame.\n"
	},
	"frame 011": {
		"prefix": "frame:preprocess( string )",
		"body": [
			"frame:preprocess( ${1:string} )$0"
		],
		"description": "Expand the string in the context of the frame.\n"
	},
	"frame 012": {
		"prefix": "frame:preprocess{ text = string }",
		"body": [
			"frame:preprocess{ text = ${1:string} }$0"
		],
		"description": "Expand the string in the context of the frame.\n"
	},
	"frame 013": {
		"prefix": "frame:getArgument( arg )",
		"body": [
			"frame:getArgument( ${1:arg} )$0"
		],
		"description": "Gets an object for the specified argument, or nil if the argument is not provided.\n"
	},
	"frame 014": {
		"prefix": "frame:getArgument{ name = arg }",
		"body": [
			"frame:getArgument{ name = ${1:arg} }$0"
		],
		"description": "Gets an object for the specified argument, or nil if the argument is not provided.\n"
	},
	"frame 015": {
		"prefix": "frame:newParserValue( text )",
		"body": [
			"frame:newParserValue( ${1:text} )$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 016": {
		"prefix": "frame:newParserValue( text = text )",
		"body": [
			"frame:newParserValue{ text = ${1:text} }$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 017": {
		"prefix": "frame:newTemplateParserValue{ title = title, args = table }",
		"body": [
			"frame:newTemplateParserValue{ title = ${1:title}, args = ${2:table} }$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 018": {
		"prefix": "frame:argumentPairs()",
		"body": [
			"frame:argumentPairs()$0"
		],
		"description": "Same as pairs( frame.args )\n"
	},
	"mw.hash 001": {
		"prefix": "mw.hash.hashValue( algo, value )",
		"body": [
			"mw.hash.hashValue( ${1:algo}, ${2:value} )$0"
		],
		"description": "Hashes a string value with the specified algorithm.\n"
	},
	"mw.hash 002": {
		"prefix": "mw.hash.listAlgorithms()",
		"body": [
			"mw.hash.listAlgorithms()$0"
		],
		"description": "Returns a list of supported hashing algorithms.\n"
	},
	"mw.html 001": {
		"prefix": "mw.html.create( tagName, args )",
		"body": [
			"mw.html.create( ${1:tagName}${2:, ${3:args}} )$0"
		],
		"description": "Creates a new instance with the given tag.\n"
	},
	"mw.html 002": {
		"prefix": "mw.html:node( builder )",
		"body": [
			":node( ${1:builder} )$0"
		],
		"description": "Appends a child to the current node.\n"
	},
	"mw.html 003": {
		"prefix": "mw.html:wikitext( ... )",
		"body": [
			":wikitext( ${1:...} )$0"
		],
		"description": "Appends wikitext strings to the current node.\n"
	},
	"mw.html 004": {
		"prefix": "mw.html:newline()",
		"body": [
			":newline()$0"
		],
		"description": "Appends a newline to the current node.\n"
	},
	"mw.html 005": {
		"prefix": "mw.html:tag( tagName, args )",
		"body": [
			":tag( ${1:tagName}, ${2:args} )$0"
		],
		"description": "Appends a new child node with the given tag to the current node.\n"
	},
	"mw.html 006": {
		"prefix": "mw.html:attr( name, value )",
		"body": [
			":attr( ${1:name}, ${2:value} )$0"
		],
		"description": "Set a html attribute with the given name and value on the current node.\n"
	},
	"mw.html 007": {
		"prefix": "mw.html:attr( table )",
		"body": [
			":attr( ${1:table} )$0"
		],
		"description": "Set html attributes with the given name and value on the current node.\n"
	},
	"mw.html 008": {
		"prefix": "mw.html:getAttr( name )",
		"body": [
			":getAttr( ${1:name} )$0"
		],
		"description": "Get the value of a html attribute previously set on the current node.\n"
	},
	"mw.html 009": {
		"prefix": "mw.html:addClass( class )",
		"body": [
			":addClass( ${1:class} )$0"
		],
		"description": "Adds the class name to the current node.\n"
	},
	"mw.html 010": {
		"prefix": "mw.html:css( name, value )",
		"body": [
			":css( ${1:name}, ${2:value} )$0"
		],
		"description": "Set a css property with the given name and value on the current node.\n"
	},
	"mw.html 011": {
		"prefix": "mw.html:css( table )",
		"body": [
			":css( ${1:table} )$0"
		],
		"description": "Set css properties with the given name and value on the current node.\n"
	},
	"mw.html 012": {
		"prefix": "mw.html:cssText( css )",
		"body": [
			":cssText( ${1:css} )$0"
		],
		"description": "Add raw css to the style attribute on the current node.\n"
	},
	"mw.html 013": {
		"prefix": "mw.html:done()",
		"body": [
			":done()$0"
		],
		"description": "Returns the parent node under which the current node was created.\n"
	},
	"mw.html 014": {
		"prefix": "mw.html:allDone()",
		"body": [
			":allDone()$0"
		],
		"description": "Returns the root node under which the current node was created."
	},
	"mw.language 001": {
		"prefix": "mw.language.fetchLanguageName( code, inLanguage )",
		"body": [
			"mw.language.fetchLanguageName( ${1:code}, ${2:inLanguage} )$0"
		],
		"description": "The full name of the language for the given language code.\n"
	},
	"mw.language 002": {
		"prefix": "mw.language.fetchLanguageNames( inLanguage, include )",
		"body": [
			"mw.language.fetchLanguageNames( ${1:inLanguage}${2:, ${3:include}} )$0"
		],
		"description": "Fetch the list of known languages.\n"
	},
	"mw.language 003": {
		"prefix": "mw.language.getContentLanguage()",
		"body": [
			"mw.language.getContentLanguage()$0"
		],
		"description": "Returns a language object for the default content language.\n"
	},
	"mw.language 004": {
		"prefix": "mw.language.getContentLanguage()",
		"body": [
			"mw.getContentLanguage()$0"
		],
		"description": "Returns a language object for the default content language.\n"
	},
	"mw.language 005": {
		"prefix": "mw.language.getFallbacksFor( code )",
		"body": [
			"mw.language.getFallbacksFor( ${1:code} )$0"
		],
		"description": "Returns a list of fallback language codes for the given code.\n"
	},
	"mw.language 006": {
		"prefix": "mw.language.isKnownLanguageTag( code )",
		"body": [
			"mw.language.isKnownLanguageTag( ${1:code} )$0"
		],
		"description": "Checks whether language code is a valid built-in code with known denomyn.\n"
	},
	"mw.language 007": {
		"prefix": "mw.language.isSupportedLanguage( code )",
		"body": [
			"mw.language.isSupportedLanguage( ${1:code} )$0"
		],
		"description": "Checks whether localisation is available for the language code.\n"
	},
	"mw.language 008": {
		"prefix": "mw.language.isValidBuiltInCode( code )",
		"body": [
			"mw.language.isValidBuiltInCode( ${1:code} )$0"
		],
		"description": "Checks whether the language code is valid for internal customisation.\n"
	},
	"mw.language 009": {
		"prefix": "mw.language.isValidCode( code )",
		"body": [
			"mw.language.isValidCode( ${1:code} )$0"
		],
		"description": "Checks whether the language code is superficially valid.\n"
	},
	"mw.language 010": {
		"prefix": "mw.language.new( code )",
		"body": [
			"mw.language.new( ${1:code} )$0"
		],
		"description": "Creates a new language object."
	},
	"mw.language 011": {
		"prefix": "mw.getLanguage( code )",
		"body": [
			"mw.getLanguage( ${1:code} )$0"
		],
		"description": "Creates a new language object."
	},
	"mw.language 012": {
		"prefix": "mw.language:getCode()",
		"body": [
			":getCode()$0"
		],
		"description": "Get the language code for the current language object.\n"
	},
	"mw.language 013": {
		"prefix": "mw.language:getFallbackLanguages()",
		"body": [
			":getFallbackLanguages()$0"
		],
		"description": "Get a list of language fallback codes for the current language object.\n"
	},
	"mw.language 014": {
		"prefix": "mw.language:isRTL()",
		"body": [
			":isRTL()$0"
		],
		"description": "Checks whether the language code is right-to-left.\n"
	},
	"mw.language 015": {
		"prefix": "mw.language:lc( s )",
		"body": [
			":lc( ${1:s} )$0"
		],
		"description": "Converts the whole string to lowercase.\n"
	},
	"mw.language 016": {
		"prefix": "mw.language:lcfirst( s )",
		"body": [
			":lcfirst( ${1:s} )$0"
		],
		"description": "Converts the first char in the string to lowercase.\n"
	},
	"mw.language 017": {
		"prefix": "mw.language:uc( s )",
		"body": [
			":uc( ${1:s} )$0"
		],
		"description": "Converts the whole string to uppercase.\n"
	},
	"mw.language 018": {
		"prefix": "mw.language:ucfirst( s )",
		"body": [
			":ucfirst( ${1:s} )$0"
		],
		"description": "Converts the first char in the string to uppercase.\n"
	},
	"mw.language 019": {
		"prefix": "mw.language:caseFold( s )",
		"body": [
			":caseFold( ${1:s} )$0"
		],
		"description": "Converts the string for case-insensitive comparison.\n"
	},
	"mw.language 020": {
		"prefix": "mw.language:formatNum( n, options )",
		"body": [
			":formatNum( ${1:n}${2:, ${3:options}} )$0"
		],
		"description": "Formats a number according to rules for the given language.\n"
	},
	"mw.language 021": {
		"prefix": "mw.language:formatDate( format, timestamp[, local] )",
		"body": [
			":formatDate( ${1:format}, ${2:timestamp}${3:, ${4:local}} )$0"
		],
		"description": "Formats a date according to rules for the given language.\n"
	},
	"mw.language 022": {
		"prefix": "mw.language:formatDuration( seconds[, allowedIntervals] )",
		"body": [
			":formatDuration( ${1:seconds}${2:, ${3:allowedIntervals}} )$0"
		],
		"description": "Formats a duration according to rules for the given language.\n"
	},
	"mw.language 023": {
		"prefix": "mw.language:parseFormattedNumber( s )",
		"body": [
			":parseFormattedNumber( ${1:s} )$0"
		],
		"description": "Inverts a formatted number in a given language into its source form.\n"
	},
	"mw.language 024": {
		"prefix": "mw.language:convertPlural( n, ... )",
		"body": [
			":convertPlural( ${1:n}, ${2:...} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 025": {
		"prefix": "mw.language:convertPlural( n, forms )",
		"body": [
			":convertPlural( ${1:n}, ${2:forms} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 026": {
		"prefix": "mw.language:plural( n, ... )",
		"body": [
			":plural( ${1:n}, ${2:...} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 027": {
		"prefix": "mw.language:plural( n, forms )",
		"body": [
			":plural( ${1:n}, ${2:forms} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 028": {
		"prefix": "mw.language:convertGrammar( word, case )",
		"body": [
			":convertGrammar( ${1:word}, ${2:case} )$0"
		],
		"description": "Choose the appropriate inflection given the language.\n"
	},
	"mw.language 029": {
		"prefix": "mw.language:grammar( case, word )",
		"body": [
			":grammar( ${1:word}, ${2:case} )$0"
		],
		"description": "Choose the appropriate inflection given the language.\n"
	},
	"mw.language 030": {
		"prefix": "mw.language:gender( what, masculine, feminine, neutral )",
		"body": [
			":gender( ${1:what}, ${2:masculine}, ${3:feminine}, ${4:neutral} )$0"
		],
		"description": "Choose the appropriate gender form given the language.\n"
	},
	"mw.language 031": {
		"prefix": "mw.language:gender( what, { masculine, feminine, neutral } )",
		"body": [
			":gender( ${1:what}, { ${2:masculine}, ${3:feminine}, ${4:neutral} } )$0"
		],
		"description": "Choose the appropriate gender form given the language.\n"
	},
	"mw.language 032": {
		"prefix": "mw.language:getArrow( direction )",
		"body": [
			":getArrow( ${1:direction} )$0"
		],
		"description": "Get a Unicode arrow character corresponding to direction given the language.\n"
	},
	"mw.language 033": {
		"prefix": "mw.language:getDir()",
		"body": [
			":getDir()$0"
		],
		"description": "Get the Unicode direction mark given the language.\n"
	},
	"mw.language 034": {
		"prefix": "mw.language:getDirMark( opposite )",
		"body": [
			":getDirMark( ${1:opposite} )$0"
		],
		"description": "Get the Unicode direction mark corresponding to opposite given the language.\n"
	},
	"mw.language 035": {
		"prefix": "mw.language:getDirMarkEntity( opposite )",
		"body": [
			":getDirMarkEntity( ${1:opposite} )$0"
		],
		"description": "mw.language:getDirMarkEntity( opposite )\n opposite - boolean for inverting direction"
	},
	"mw.language 036": {
		"prefix": "mw.language:getDurationIntervals( seconds )",
		"body": [
			":getDurationIntervals( ${1:seconds} )$0"
		],
		"description": "Divides a duration according to rules for the given language.\n"
	},
	"mw.language 037": {
		"prefix": "mw.language:getDurationIntervals( seconds, allowedIntervals )",
		"body": [
			":getDurationIntervals( ${1:seconds}${2:, ${3:allowedIntervals}} )$0"
		],
		"description": "Divides a duration according to rules for the given language.\n"
	},
	"util 001": {
		"prefix": "libraryUtil.checkType( name, argIdx, arg, expectType, nilOk )",
		"body": [
			"libraryUtil.checkType( ${1:name}, ${2:argIdx}, ${3:arg}, ${4:expectType}, ${5:nilOk} )$0"
		],
		"description": "Check type and raise exception on wrong type.\n"
	},
	"util 002": {
		"prefix": "libraryUtil.checkTypeMulti( name, argIdx, arg, expectTypes )",
		"body": [
			"libraryUtil.checkTypeMulti( ${1:name}, ${2:argIdx}, ${3:arg}, ${4:expectTypes} )$0"
		],
		"description": "Check types and raise exception if type is not listed.\n"
	},
	"util 003": {
		"prefix": "libraryUtil.checkTypeForIndex( index, value, expectType )",
		"body": [
			"libraryUtil.checkTypeForIndex( ${1:index}, ${2:value}, ${3:expectType} )$0"
		],
		"description": "Raises an error if type of value does not match.\n"
	},
	"util 004": {
		"prefix": "libraryUtil.checkTypeForNamedArg( name, argName, arg, expectType, nilOk )",
		"body": [
			"libraryUtil.checkTypeForNamedArg( ${1:name}, ${2:argName}, ${3:arg}, ${4:expectType}, ${5:nilOk} )$0"
		],
		"description": "Raises an error if type of arg does not match.\n"
	},
	"util 005": {
		"prefix": "makeCheckSelfFunction( libraryName, varName, selfObj, selfObjDesc )",
		"body": [
			"makeCheckSelfFunction( ${1:libraryName}, ${2:varName}, ${3:selfObj}, ${4:selfObjDesc} )$0"
		],
		"description": "Returns a function for self-tests.\n"
	},
	"mw 001": {
		"prefix": "mw.addWarning( text )",
		"body": [
			"mw.addWarning( ${1:text} )$0"
		],
		"description": "Adds a warning above the preview during editing.\n"
	},
	"mw 002": {
		"prefix": "mw.allToString( ... )",
		"body": [
			"mw.allToString( ${1:...} )$0"
		],
		"description": "Calls tostring() on all arguments and concatenates them.\n"
	},
	"mw 003": {
		"prefix": "mw.clone( value )",
		"body": [
			"mw.clone( ${1:value} )$0"
		],
		"description": "Creates a deep copy of a value.\n"
	},
	"mw 004": {
		"prefix": "mw.getCurrentFrame()",
		"body": [
			"mw.getCurrentFrame()$0"
		],
		"description": "Get the current frame object.\n"
	},
	"mw 005": {
		"prefix": "mw.incrementExpensiveFunctionCount()",
		"body": [
			"mw.incrementExpensiveFunctionCount()$0"
		],
		"description": "Adds one to the count, and throws an exception when overflowing.\n"
	},
	"mw 006": {
		"prefix": "mw.isSubsting()",
		"body": [
			"mw.isSubsting()$0"
		],
		"description": "Checks if last invoke is substed.\n"
	},
	"mw 007": {
		"prefix": "mw.loadData( module )",
		"body": [
			"mw.loadData( ${1:module} )$0"
		],
		"description": "Loads data from a separate page.\n"
	},
	"mw 008": {
		"prefix": "mw.dumpObject( object )",
		"body": [
			"mw.dumpObject( ${1:object} )$0"
		],
		"description": "Serializes object to a human-readable representation.\n"
	},
	"mw 009": {
		"prefix": "mw.log( ... )",
		"body": [
			"mw.log( ${1:...} )$0"
		],
		"description": "Surface serialize and appends the result to the log buffer.\n"
	},
	"mw 010": {
		"prefix": "mw.logObject ( object, prefix )",
		"body": [
			"mw.logObject( ${1:object}${2:, ${3:prefix}} )$0"
		],
		"description": "Serializes object to a human-readable representation and appends the result to the log buffer.\n"
	},
	"mw.title 001 ": {
		"prefix": "mw.title.equals( a, b )",
		"body": [
			"mw.title.equals( ${1:a}, ${2:b} )$0"
		],
		"description": "Checks whether two titles are logical equal, as a boolean.\n"
	},
	"mw.title 002 ": {
		"prefix": "mw.title.compare( a, b )",
		"body": [
			"mw.title.compare( ${1:a}, ${2:b} )$0"
		],
		"description": "Chekshow two titles are grammatically ordered, as an integer.\n"
	},
	"mw.title 003 ": {
		"prefix": "mw.title.getCurrentTitle()",
		"body": [
			"mw.title.getCurrentTitle()$0"
		],
		"description": "Gets the title for the current page, as an object.\n"
	},
	"mw.title 004 ": {
		"prefix": "mw.title.new( text, namespace)",
		"body": [
			"mw.title.new( ${1:text}, ${2:namespace} )$0"
		],
		"description": "Creates a new title object.\n"
	},
	"mw.title 005 ": {
		"prefix": "mw.title.new( id)",
		"body": [
			"mw.title.new( ${1:id} )$0"
		],
		"description": "Creates a new title object.\n"
	},
	"mw.title 006 ": {
		"prefix": "mw.title.makeTitle( namespace, title, fragment, interwiki )",
		"body": [
			"mw.title.makeTitle( ${1:namespace}, ${2:title}${3:, ${4:fragment}${5:, ${6:interwiki}}} )$0"
		],
		"description": "Creates a title object in the given namespace namespace.\n"
	},
	"mw.title 007 ": {
		"prefix": "mw.title.id",
		"body": [
			".id$0"
		],
		"description": "The instance id, as an integer(?).\n"
	},
	"mw.title 008 ": {
		"prefix": "mw.title.interwiki",
		"body": [
			".interwiki$0"
		],
		"description": "The instance interwiki, as a string.\n"
	},
	"mw.title 009 ": {
		"prefix": "mw.title.namespace",
		"body": [
			".namespace$0"
		],
		"description": "The instance namespace, as an integer.\n"
	},
	"mw.title 010 ": {
		"prefix": "mw.title.fragment",
		"body": [
			".fragment$0"
		],
		"description": "The instance fragment, as a string.\n"
	},
	"mw.title 011 ": {
		"prefix": "mw.title.nsText",
		"body": [
			".nsText$0"
		],
		"description": "The instance namespace text, as a string.\n"
	},
	"mw.title 012 ": {
		"prefix": "mw.title.subjectNsText",
		"body": [
			".subjectNsText$0"
		],
		"description": "The instance subject namespace text, as a string.\n"
	},
	"mw.title 013 ": {
		"prefix": "mw.title.text",
		"body": [
			".text$0"
		],
		"description": "The instance text, as a string.\n"
	},
	"mw.title 014 ": {
		"prefix": "mw.title.prefixedText",
		"body": [
			".prefixedText$0"
		],
		"description": "The instance prefixed text, as a string.\n"
	},
	"mw.title 015 ": {
		"prefix": "mw.title.fullText",
		"body": [
			".fullText$0"
		],
		"description": "The instance full text, as a string.\n"
	},
	"mw.title 016 ": {
		"prefix": "mw.title.rootText",
		"body": [
			".rootText$0"
		],
		"description": "The instance root text, as a string.\n"
	},
	"mw.title 017 ": {
		"prefix": "mw.title.baseText",
		"body": [
			".baseText$0"
		],
		"description": "The instance base text, as a string.\n"
	},
	"mw.title 018 ": {
		"prefix": "mw.title.subpageText",
		"body": [
			".subpageText$0"
		],
		"description": "The instance subpage text, as a string.\n"
	},
	"mw.title 019 ": {
		"prefix": "mw.title.canTalk",
		"body": [
			".canTalk$0"
		],
		"description": "Whether the instance can have a talk page, as a boolean(?).\n"
	},
	"mw.title 020 ": {
		"prefix": "mw.title.exists",
		"body": [
			".exists$0"
		],
		"description": "Whether the instance exists, as a boolean.\n"
	},
	"mw.title 021 ": {
		"prefix": "mw.title.fileExists",
		"body": [
			".fileExists$0"
		],
		"description": "Whether the instance has a file substructure, as a boolean(?).\n"
	},
	"mw.title 022 ": {
		"prefix": "mw.title.file",
		"body": [
			".file$0"
		],
		"description": "Root for the instance file substructure, as a table.\n"
	},
	"mw.title 023 ": {
		"prefix": "mw.title.isContentPage",
		"body": [
			".isContentPage$0"
		],
		"description": "Whether the instance is in a content namespace, as a boolean.\n"
	},
	"mw.title 024 ": {
		"prefix": "mw.title.isExternal",
		"body": [
			".isExternal$0"
		],
		"description": "Whether the instance has an interwiki prefix, as a boolean.\n"
	},
	"mw.title 025 ": {
		"prefix": "mw.title.isLocal",
		"body": [
			".isLocal$0"
		],
		"description": "Whether the instance is local to the project, as a boolean.\n"
	},
	"mw.title 026 ": {
		"prefix": "mw.title.isRedirect",
		"body": [
			".isRedirect$0"
		],
		"description": "Whether the instance is a redirect, as a boolean.\n"
	},
	"mw.title 027 ": {
		"prefix": "mw.title.isSpecialPage",
		"body": [
			".isSpecialPage$0"
		],
		"description": "Whether the instance is a special page, as a boolean.\n"
	},
	"mw.title 028 ": {
		"prefix": "mw.title.isSubpage",
		"body": [
			".isSubpage$0"
		],
		"description": "Whether the instance is a subpage, as a boolean.\n"
	},
	"mw.title 029 ": {
		"prefix": "mw.title.isTalkPage",
		"body": [
			".isTalkPage$0"
		],
		"description": "Whether the instance is a talk page, as a boolean.\n"
	},
	"mw.title 030 ": {
		"prefix": "mw.title:isSubpageOf( title2 )",
		"body": [
			":isSubpageOf( ${1:title2} )$0"
		],
		"description": "Checks whether the instance is a subpage of the current title, as a boolean.\n"
	},
	"mw.title 031 ": {
		"prefix": "mw.title:inNamespace( ns )",
		"body": [
			":inNamespace( ${1:ns} ):$0"
		],
		"description": "Checks whether the instance is within the given namespace, as a boolean.\n"
	},
	"mw.title 032 ": {
		"prefix": "mw.title:inNamespaces( ... )",
		"body": [
			":inNamespaces( $1{:...} )$0"
		],
		"description": "Checks whether the instance is within one of the given namespaces, as a boolean.\n"
	},
	"mw.title 033 ": {
		"prefix": "mw.title:hasSubjectNamespace( ns )",
		"body": [
			":hasSubjectNamespace( ${1:ns} )$0"
		],
		"description": "Checks whether the instance subject namespace is within the given namespace, as a boolean.\n"
	},
	"mw.title 034 ": {
		"prefix": "mw.title.contentModel",
		"body": [
			".contentModel$0"
		],
		"description": "The instance content model, as a string.\n"
	},
	"mw.title 035 ": {
		"prefix": "mw.title.basePageTitle",
		"body": [
			".basePageTitle$0"
		],
		"description": "The instance base page title, as a title object.\n"
	},
	"mw.title 036 ": {
		"prefix": "mw.title.rootPageTitle",
		"body": [
			".rootPageTitle$0"
		],
		"description": "The instance root page title, as a title object.\n"
	},
	"mw.title 037 ": {
		"prefix": "mw.title.talkPageTitle",
		"body": [
			".talkPageTitle$0"
		],
		"description": "The instance talk page title, as a title object.\n"
	},
	"mw.title 038 ": {
		"prefix": "mw.title.subjectPageTitle",
		"body": [
			".subjectPageTitle$0"
		],
		"description": "The instance subject page title, as a title object.\n"
	},
	"mw.title 039 ": {
		"prefix": "mw.title.redirectTarget",
		"body": [
			".redirectTarget$0"
		],
		"description": "Gets the instance target if it is a redirect, as a title object.\n"
	},
	"mw.title 040 ": {
		"prefix": "mw.title.protectionLevels",
		"body": [
			".protectionLevels$0"
		],
		"description": "The instance protection level, as a table.\n"
	},
	"mw.title 041 ": {
		"prefix": "mw.title:subPageTitle( text )",
		"body": [
			":subPageTitle( ${1:text} )$0"
		],
		"description": "Sets the instance subpage title, as a title object.\n"
	},
	"mw.title 042 ": {
		"prefix": "mw.title:partialUrl( query, proto )",
		"body": [
			":$0"
		],
		"description": "Gets the instance subject page title, as a string.\n"
	},
	"mw.title 043 ": {
		"prefix": "mw.title:localUrl( query )",
		"body": [
			":partialUrl( ${1:query}, ${2:proto} )$0"
		],
		"description": "The instance local url, as a (?)\n"
	},
	"mw.title 044 ": {
		"prefix": "mw.title:canonicalUrl( query )",
		"body": [
			":canonicalUrl( ${1:query} )$0"
		],
		"description": "The instance canonical url, as a (?)\n"
	},
	"mw.title 045 ": {
		"prefix": "mw.title:getContent()",
		"body": [
			":getContent()$0"
		],
		"description": "The instance unparsed content, as a string.\n"
	},
	"mw.title 046 ": {
		"prefix": "mw.title.file.exists",
		"body": [
			".exists$0"
		],
		"description": "Whether the instance exists, as a boolean.\n"
	},
	"mw.title 047 ": {
		"prefix": "mw.title.file.width",
		"body": [
			".width$0"
		],
		"description": "The instance width, as an integer.\n"
	},
	"mw.title 048 ": {
		"prefix": "mw.title.file.height",
		"body": [
			".height$0"
		],
		"description": "The instance height, as an integer.\n"
	},
	"mw.title 049 ": {
		"prefix": "mw.title.file.pages",
		"body": [
			".pages$0"
		],
		"description": "The instance pages, as a table.\n"
	},
	"mw.title 050 ": {
		"prefix": "mw.title.file.size",
		"body": [
			".size$0"
		],
		"description": "The instance size, in bytes.\n"
	},
	"mw.title 051 ": {
		"prefix": "mw.title.file.mimeType",
		"body": [
			".mimeType$0"
		],
		"description": "The instance mime type, as a string.\n"
	},
	"mw.uri 001 ": {
		"prefix": "mw.uri.encode( s[, enctype] )",
		"body": [
			"mw.uri.encode( ${1:s}${2:, ${3:enctype}} )$0"
		],
		"description": "Percent-encodes the string.\n"
	},
	"mw.uri 002 ": {
		"prefix": "mw.uri.decode( s[, enctype] )",
		"body": [
			"mw.uri.decode( ${1:s}${2:, ${3:enctype}} )$0"
		],
		"description": "Percent-decodes the string.\n"
	},
	"mw.uri 003 ": {
		"prefix": "mw.uri.anchorEncode( s )",
		"body": [
			"mw.uri.anchorEncode( ${1:s} )$0"
		],
		"description": "Encodes the string for use in a uri fragment.\n"
	},
	"mw.uri 004 ": {
		"prefix": "mw.uri.buildQueryString( table )",
		"body": [
			"mw.uri.buildQueryString( ${1:table} )$0"
		],
		"description": "Encodes the table as a uri query string.\n"
	},
	"mw.uri 005 ": {
		"prefix": "mw.uri.parseQueryString( s, i, j )",
		"body": [
			"mw.uri.parseQueryString( ${1:s}, ${2:i}, ${3:j} )$0"
		],
		"description": "Decodes the query string s to a table.\n"
	},
	"mw.uri 006 ": {
		"prefix": "mw.uri.canonicalUrl( page[, query] )",
		"body": [
			"mw.uri.canonicalUrl( ${1:page}${2:, ${3:query}} )$0"
		],
		"description": "Returns a uri for the canonical url, with optional query string/table.\n"
	},
	"mw.uri 007 ": {
		"prefix": "mw.uri.fullUrl( page[, query] )",
		"body": [
			"mw.uri.fullUrl( ${1:page}${2:, ${3:query}} )$0"
		],
		"description": "Returns a uri for the full url, with optional query string/table.\n"
	},
	"mw.uri 008 ": {
		"prefix": "mw.uri.localUrl(  page[, query] )",
		"body": [
			"mw.uri.localUrl( ${1:page}${2:, ${3:query}} )$0"
		],
		"description": "Returns a uri for the full url, with optional query string/table.\n"
	},
	"mw.uri 009 ": {
		"prefix": "mw.uri.new( s )",
		"body": [
			"mw.uri.new( ${1:s} )$0"
		],
		"description": "Constructs a new uri object for the passed string or table.\n"
	},
	"mw.uri 010 ": {
		"prefix": "mw.uri.validate( table )",
		"body": [
			"mw.uri.validate( ${1:table} )$0"
		],
		"description": "Validates the passed table or uri object.\n"
	},
	"mw.uri 011 ": {
		"prefix": "mw.uri:parse( s )",
		"body": [
			":parse( ${1:s} )$0"
		],
		"description": "Parses a string into the current uri object.\n"
	},
	"mw.uri 012 ": {
		"prefix": "mw.uri:clone()",
		"body": [
			":clone()$0"
		],
		"description": "Makes a copy of the URI object.\n"
	},
	"mw.uri 013 ": {
		"prefix": "mw.uri:extend( parameters )",
		"body": [
			":extend( ${1:parameters} )$0"
		],
		"description": "Merges the parameters into the object's query table.\n"
	},
	"mw.ustring 001": {
		"prefix": "mw.ustring.maxPatternLength",
		"body": [
			"mw.ustring.maxPatternLength$0"
		],
		"description": "The maximum allowed length of a pattern, in bytes.\n"
	},
	"mw.ustring 002": {
		"prefix": "mw.ustring.maxStringLength",
		"body": [
			"mw.ustring.maxPatternLength$0"
		],
		"description": "The maximum allowed length of a ustring, in bytes.\n"
	},
	"mw.ustring 003": {
		"prefix": "mw.ustring.byte( s[, i[, j]] )",
		"body": [
			"mw.ustring.byte( ${1:s}${2:, ${3:i}${4:, ${5:j}}} )$0"
		],
		"description": "Returns the ustring as an array of bytes.\n"
	},
	"mw.ustring 004": {
		"prefix": "mw.ustring.byteoffset( s[, l[, i]] )",
		"body": [
			"mw.ustring.byteoffset( ${1:s}${2:, ${3:l}${4:, ${5:i}}} )$0"
		],
		"description": "Returns the byte offset of a character in the ustring.\n"
	},
	"mw.ustring 005": {
		"prefix": "mw.ustring.char( ... )",
		"body": [
			"mw.ustring.char( ${1:...} )$0"
		],
		"description": "Returns the arguments as a ustring of chars.\n"
	},
	"mw.ustring 006": {
		"prefix": "mw.ustring.codepoint( s[, i[, j]] )",
		"body": [
			"mw.ustring.codepoint( ${1:s}${2:, ${3:i}${4:, ${5:j}}} )$0"
		],
		"description": "Returns the ustring as an array of codepoints.\n"
	},
	"mw.ustring 007": {
		"prefix": "mw.ustring.find( s, pattern[, init[, plain]] )",
		"body": [
			"mw.ustring.find( ${1:s}, ${2:pattern}${3:, ${4:init}${5:, ${6:plain}}} )$0"
		],
		"description": "Search for the first occurence of pattern within the ustring.\n"
	},
	"mw.ustring 008": {
		"prefix": "mw.ustring.format( format[, ...] )",
		"body": [
			"mw.ustring.format( ${1:format}${2:, ${3:...}} )$0"
		],
		"description": "Formats the ustring, and injects optional arguments.\n"
	},
	"mw.ustring 009": {
		"prefix": "mw.ustring.gcodepoint( s[, i[, j]] )",
		"body": [
			"mw.ustring.gcodepoint( ${1:s}${2:, ${3:i}${4:, ${5:j}}} )$0"
		],
		"description": "Creates an iterator for the codepoints from the given arguments.\n"
	},
	"mw.ustring 010": {
		"prefix": "mw.ustring.gmatch( s, pattern )",
		"body": [
			"mw.ustring.gmatch( ${1:s}, ${2:pattern} )$0"
		],
		"description": "Creates an iterator for the captures from the given arguments.\n"
	},
	"mw.ustring 011": {
		"prefix": "mw.ustring.gsub( s, pattern, repl[, n] )",
		"body": [
			"mw.ustring.gsub(${1:s}, ${2:pattern}, ${3:repl}${4:, ${5:n}} )$0"
		],
		"description": "Returns the ustring with occurences of patterns replaced.\n"
	},
	"mw.ustring 012": {
		"prefix": "mw.ustring.isutf8( s )",
		"body": [
			"mw.ustring.isutf8( ${1:s} )$0"
		],
		"description": "Checks whether the ustring is valid UTF-8.\n"
	},
	"mw.ustring 013": {
		"prefix": "mw.ustring.len( s )",
		"body": [
			"mw.ustring.len( ${1:s} )$0"
		],
		"description": "Calculates the length of the string in bytes.\n"
	},
	"mw.ustring 014": {
		"prefix": "mw.ustring.lower( s )",
		"body": [
			"mw.ustring.lower( ${1:s} )$0"
		],
		"description": "Change all unicode uppercase letters to lowercase.\n"
	},
	"mw.ustring 015": {
		"prefix": "mw.ustring.match( s, pattern[, init] )",
		"body": [
			"mw.ustring.match( ${1:s}, ${2:pattern}${3:, ${4:init}} )$0"
		],
		"description": "Returns the first part matched by pattern.\n"
	},
	"mw.ustring 016": {
		"prefix": "mw.ustring.rep( s, n )",
		"body": [
			"mw.ustring.rep( ${1:s}, ${2:n} )$0"
		],
		"description": "Returns a string with n copies of s.\n"
	},
	"mw.ustring 017": {
		"prefix": "mw.ustring.sub( s, i[, j] )",
		"body": [
			"mw.ustring.sub( ${1:s}, ${2:i}${3:, ${4:j}} )$0"
		],
		"description": "Returns the part given by the arguments.\n"
	},
	"mw.ustring 018": {
		"prefix": "mw.ustring.toNFC( s )",
		"body": [
			"mw.ustring.toNFC( ${1:s} )$0"
		],
		"description": "Converts the string to Normalization Form C.\n"
	},
	"mw.ustring 019": {
		"prefix": "mw.ustring.toNFD( s )",
		"body": [
			"mw.ustring.toNFD( ${1:s} )$0"
		],
		"description": "Converts the string to Normalization Form D.\n"
	},
	"mw.ustring 020": {
		"prefix": "mw.ustring.upper( s )",
		"body": [
			"mw.ustring.upper( ${1:s} )$0"
		],
		"description": "Change all unicode lowercase letters to uppercase.\n"
	},
	"mw.wikibase 001": {
		"prefix": "mw.wikibase.getEntity( [entityId] )",
		"body": [
			"mw.wikibase.getEntity( ${1:entityId} )$0"
		],
		"description": "Returns the entity forthe current item, or the one with the entity id.\n"
	},
	"mw.wikibase 002": {
		"prefix": "mw.wikibase.getEntityObject( [entityId] )",
		"body": [
			"mw.wikibase.getEntityObject( ${1:entityId} )$0"
		],
		"description": "Returns the entity for the current item, or the one with the entity id.\nAlias for mw.wikibase.getEntity\n"
	},
	"mw.wikibase 003": {
		"prefix": "mw.wikibase.getEntityIdForCurrentPage()",
		"body": [
			"mw.wikibase.getEntityIdForCurrentPage()$0"
		],
		"description": "Returns the entity id for the current page.\n"
	},
	"mw.wikibase 004": {
		"prefix": "mw.wikibase.getEntityIdForTitle( title )",
		"body": [
			"mw.wikibase.getEntityIdForTitle( ${1:title} )"
		],
		"description": "Returns the entity id for the linked title.\n"
	},
	"mw.wikibase 005": {
		"prefix": "mw.wikibase.getEntityUrl( [entityId] )",
		"body": [
			"mw.wikibase.getEntityUrl( ${1:entityId} )$0"
		],
		"description": "Returns the url for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 006": {
		"prefix": "mw.wikibase.label( [entityId] )",
		"body": [
			"mw.wikibase.label( ${1:entityId} )$0"
		],
		"description": "Returns the label for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 007": {
		"prefix": "mw.wikibase.getLabelWithLang( [entityId] )",
		"body": [
			"mw.wikibase.getLabelWithLang( ${1:entityId} )$0"
		],
		"description": "Returns the label and language for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 008": {
		"prefix": "mw.wikibase.sitelink( [entityId] )",
		"body": [
			"mw.wikibase.sitelink( ${1:entityId} )$0"
		],
		"description": "Returns the sitelink (page title) for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 009": {
		"prefix": "mw.wikibase.description( [entityId] )",
		"body": [
			"mw.wikibase.description( ${1:entityId} )$0"
		],
		"description": "Returns the description for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 010": {
		"prefix": "mw.wikibase.getDescriptionWithLang( [entityId] )",
		"body": [
			"mw.wikibase.getDescriptionWithLang( ${1:entityId} )$0"
		],
		"description": "Returns the description and language for the current item, or the one with the entity id.\n"
	},
	"mw.wikibase 011": {
		"prefix": "mw.wikibase.renderSnak( snak )",
		"body": [
			"mw.wikibase.renderSnak( ${1:snak} )$0"
		],
		"description": "Returns an escaped wikitext version of the snak.\n"
	},
	"mw.wikibase 012": {
		"prefix": "mw.wikibase.formatValue( snak )",
		"body": [
			"mw.wikibase.formatValue( ${1:snak} )$0"
		],
		"description": "Returns a rich wikitext version of the snak.\n"
	},
	"mw.wikibase 013": {
		"prefix": "mw.wikibase.renderSnaks( snaks )",
		"body": [
			"mw.wikibase.renderSnaks( ${1:snaks} )$0"
		],
		"description": "Returns escaped wikitext versions of the snaks.\n"
	},
	"mw.wikibase 014": {
		"prefix": "mw.wikibase.formatValues( snaks )",
		"body": [
			"mw.wikibase.formatValues( ${1:snaks} )$0"
		],
		"description": "Returns rich wikitext versions of the snaks.\n"
	},
	"mw.wikibase 015": {
		"prefix": "mw.wikibase.resolvePropertyId( propertyLabelOrId )",
		"body": [
			"mw.wikibase.resolvePropertyId( ${1:propertyLabelOrId} )$0"
		],
		"description": "Returns the property id for the property with the label or id.\n"
	},
	"mw.wikibase 016": {
		"prefix": "mw.wikibase.getPropertyOrder()",
		"body": [
			"mw.wikibase.getPropertyOrder()$0"
		],
		"description": "Returns a table with properties given weights.\n"
	},
	"mw.wikibase 017": {
		"prefix": "mw.wikibase.orderProperties( propertyIds )",
		"body": [
			"mw.wikibase.orderProperties( ${1:propertyIds} )$0"
		],
		"description": "Returns a table with the property ids in sorted order.\n"
	},
	"mw.wikibase 018": {
		"prefix": "mw.wikibase.getBestStatements( entityId, propertyId )",
		"body": [
			"mw.wikibase.getBestStatements( ${1:entityId}, ${2:propertyId} )$0"
		],
		"description": "Returns the best statements for the given entity and property id.\n"
	},
	"mw.wikibase 019": {
		"prefix": "mw.wikibase:getLabel( [langCode] )",
		"body": [
			":getLabel( ${1:langCode} )$0"
		],
		"description": "Returns the label for the instance, in the current or given language.\n"
	},
	"mw.wikibase 020": {
		"prefix": "mw.wikibase:getLabelWithLang( [langCode] )",
		"body": [
			":getLabelWithLang( ${1:langCode} )$0"
		],
		"description": "Returns the label and language for the instance, in the current or given language.\n"
	},
	"mw.wikibase 021": {
		"prefix": "mw.wikibase:getSitelink( [globalSiteId] )",
		"body": [
			":getSitelink( ${1:globalSiteId} )$0"
		],
		"description": "Returns the sitelink (page title) for the instance, for the current or given global site id.\n"
	},
	"mw.wikibase 022": {
		"prefix": "mw.wikibase:getDescription( [langCode] )",
		"body": [
			":getDescription( ${1:langCode} )$0"
		],
		"description": "Returns the description for the instance, in the current or given language.\n"
	},
	"mw.wikibase 023": {
		"prefix": "mw.wikibase:getDescriptionWithLang( [langCode] )",
		"body": [
			":getDescriptionWithLang( ${1:langCode} )$0"
		],
		"description": "Returns the description and language for the instance, in the current or given language.\n"
	},
	"mw.wikibase 024": {
		"prefix": "mw.wikibase:getProperties()$0",
		"body": [
			":getProperties()"
		],
		"description": "Returns a table for the instance with all used property ids.\n"
	},
	"mw.wikibase 025": {
		"prefix": "mw.wikibase:getBestStatements( propertyId )",
		"body": [
			":getBestStatements( ${1:propertyId} )$0"
		],
		"description": "Returns the best statements for the instance, given the property id.\n"
	},
	"mw.wikibase 026": {
		"prefix": "mw.wikibase:formatPropertyValues( propertyLabelOrId[, acceptableRanks] )",
		"body": [
			":formatPropertyValues( ${1:propertyId}${2:, ${3:acceptableRanks}} )$0"
		],
		"description": "Returns an escaped wikitext version of the snak.\n"
	},
	"mw.wikibase 027": {
		"prefix": "mw.wikibase:formatStatements( propertyLabelOrId[, acceptableRanks] )",
		"body": [
			":formatStatements( ${1:propertyId}${2:, ${3:acceptableRanks}} )$0"
		],
		"description": "Returns a rich wikitext version of the snak.\n"
	},
	"mw.wikibase 028": {
		"prefix": "mw.wikibase.entity.claimRanks",
		"body": [
			"mw.wikibase.entity.claimRanks$0"
		],
		"description": "A table that contains a map of all available claim ranks.\n"
	},
	"pickle.adapt 001": {
		"prefix": "pickle.subject",
		"body": [
			"subject$0"
		],
		"description": "Access current subject.\n"
	},
	"pickle.adapt 002": {
		"prefix": "pickle.subject( obj[, ...] )",
		"body": [
			"subject( ${1:obj}${2, ${3:...}} )$0"
		],
		"description": "Create subject, add varargs, and chain on return.\n"
	},
	"pickle.adapt 003": {
		"prefix": "pickle.expect",
		"body": [
			"expect$0"
		],
		"description": "Access current expectation.\n"
	},
	"pickle.adapt 004": {
		"prefix": "pickle.expect( obj[, ...] )",
		"body": [
			"expect( ${1:obj}${2, ${3:...}} )$0"
		],
		"description": "Create an expectation, add varargs, and chain on return.\n"
	},
	"pickle.adapt 005": {
		"prefix": "pickle.adapt:first()",
		"body": [
			":first()$0"
		],
		"description": "Pick the first of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 006": {
		"prefix": "pickle.adapt:second()",
		"body": [
			":second()$0"
		],
		"description": "Pick the second of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 007": {
		"prefix": "pickle.adapt:third()",
		"body": [
			":third()$0"
		],
		"description": "Pick the third of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 008": {
		"prefix": "pickle.adapt:fourth()",
		"body": [
			":fourth()$0"
		],
		"description": "Pick the fourth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 009": {
		"prefix": "pickle.adapt:fifth()",
		"body": [
			":fifth()$0"
		],
		"description": "Pick the fifth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 010": {
		"prefix": "pickle.adapt:sixth()",
		"body": [
			":sixth()$0"
		],
		"description": "Pick the sixth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 011": {
		"prefix": "pickle.adapt:seventh()",
		"body": [
			":seventh()$0"
		],
		"description": "Pick the seventh of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 012": {
		"prefix": "pickle.adapt:eight()",
		"body": [
			":eight()$0"
		],
		"description": "Pick the eight of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 013": {
		"prefix": "pickle.adapt:ninth()",
		"body": [
			":ninth()$0"
		],
		"description": "Pick the ninth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 014": {
		"prefix": "pickle.adapt:tenth()",
		"body": [
			":tenth()$0"
		],
		"description": "Pick the tenth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 015": {
		"prefix": "pickle.adapt:eleventh()",
		"body": [
			":eleventh()$0"
		],
		"description": "Pick the eleventh of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 016": {
		"prefix": "pickle.adapt:twelfth()",
		"body": [
			":twelfth()$0"
		],
		"description": "Pick the twelfth of the internal arguments, and chain on return.\n"
	},
	"pickle.adapt 017": {
		"prefix": "pickle.adapt:asType()",
		"body": [
			":asType()$0"
		],
		"description": "Transform the internal argument to its type, and chain on return.\n"
	},
	"pickle.adapt 018": {
		"prefix": "pickle.adapt:asUpper()",
		"body": [
			":asUpper()$0"
		],
		"description": "Transform the internal argument to its uppercase string form, and chain on return.\n"
	},
	"pickle.adapt 019": {
		"prefix": "pickle.adapt:asLower()",
		"body": [
			":asLower()$0"
		],
		"description": "Transform the internal argument to its lowercase string form, and chain on return.\n"
	},
	"pickle.adapt 020": {
		"prefix": "pickle.adapt:asUpperFirst()",
		"body": [
			":asUpperFirst()$0"
		],
		"description": "Transform the internal argument to its uppercase first string form, and chain on return.\n"
	},
	"pickle.adapt 021": {
		"prefix": "pickle.adapt:asLowerFirst()",
		"body": [
			":asLowerFirst()$0"
		],
		"description": "Transform the internal argument to its lowercase string form, and chain on return.\n"
	},
	"pickle.adapt 022": {
		"prefix": "pickle.adapt:asReverse()",
		"body": [
			":asReverse()$0"
		],
		"description": "Transform the internal argument to its reverse string form, and chain on return.\n"
	},
	"pickle.adapt 023": {
		"prefix": "pickle.adapt:asUUpper()",
		"body": [
			":asUUpper()$0"
		],
		"description": "Transform the internal argument to its Unicode uppercase string form, and chain on return.\n"
	},
	"pickle.adapt 024": {
		"prefix": "pickle.adapt:asULower()",
		"body": [
			":asULower()$0"
		],
		"description": "Transform the internal argument to its Unicode lowercase string form, and chain on return.\n"
	},
	"pickle.adapt 025": {
		"prefix": "pickle.adapt:asUUpperFirst()",
		"body": [
			":asUUpperFirst()$0"
		],
		"description": "Transform the internal argument to its Unicode uppercase first string form, and chain on return.\n"
	},
	"pickle.adapt 026": {
		"prefix": "pickle.adapt:asULowerFirst()",
		"body": [
			":asULowerFirst()$0"
		],
		"description": "Transform the internal argument to its Unicode lowercase string form, and chain on return.\n"
	},
	"pickle.adapt 027": {
		"prefix": "pickle.adapt:asUNFC()",
		"body": [
			":asUNFC()$0"
		],
		"description": "Transform the internal argument to its Unicode Normalized Form C, and chain on return.\n"
	},
	"pickle.adapt 028": {
		"prefix": "pickle.adapt:asUNFD()",
		"body": [
			":asUNFD()$0"
		],
		"description": "Transform the internal argument to its Unicode Normalized Form D, and chain on return.\n"
	},
	"pickle.adapt 029": {
		"prefix": "pickle.adapt:asNumber()",
		"body": [
			":asNumber()$0"
		],
		"description": "Transform the internal argument to a number, and chain on return.\n"
	},
	"pickle.adapt 030": {
		"prefix": "pickle.adapt:asString()",
		"body": [
			":asString()$0"
		],
		"description": "Transform the internal argument to a string, and chain on return.\n"
	},
	"pickle.adapt 031": {
		"prefix": "pickle.adapt:asFloor()",
		"body": [
			":asFloor()$0"
		],
		"description": "Transform the internal argument to the lower integer, and chain on return.\n"
	},
	"pickle.adapt 032": {
		"prefix": "pickle.adapt:asCeil()",
		"body": [
			":asCeil()$0"
		],
		"description": "Transform the internal argument to the higher integer, and chain on return.\n"
	},
	"pickle.adapt 033": {
		"prefix": "pickle.adapt:asRound()",
		"body": [
			":asRound()$0"
		],
		"description": "Transform the internal argument to the rounded noumber, and chain on return.\n"
	},
	"pickle.adapt 034": {
		"prefix": "pickle.adapt:asInteger()",
		"body": [
			":asInteger()$0"
		],
		"description": "Transform the internal argument to the integer part, and chain on return.\n"
	},
	"pickle.adapt 035": {
		"prefix": "pickle.adapt:asFraction()",
		"body": [
			":asFraction()$0"
		],
		"description": "Transform the internal argument to the fraction part, and chain on return.\n"
	},
	"pickle.adapt 036": {
		"prefix": "pickle.adapt:toBeEqual()",
		"body": [
			":toBeEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is equal to second, and chain on return.\n"
	},
	"pickle.adapt 037": {
		"prefix": "pickle.adapt:toBeBooleanEqual()",
		"body": [
			":toBeBooleanEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is boolean equal to second, and chain on return.\n"
	},
	"pickle.adapt 038": {
		"prefix": "pickle.adapt:toBeStrictEqual()",
		"body": [
			":toBeStrictEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is strict equal to second, and chain on return.\n"
	},
	"pickle.adapt 039": {
		"prefix": "pickle.adapt:toBeSame()",
		"body": [
			":toBeSame()$0"
		],
		"description": "Compare the internal arguments by checking if first is same to second, and chain on return.\n"
	},
	"pickle.adapt 040": {
		"prefix": "pickle.adapt:toBeDeepEqual()",
		"body": [
			":toBeDeepEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is deep equal to second, and chain on return.\n"
	},
	"pickle.adapt 041": {
		"prefix": "pickle.adapt:toBeContained()",
		"body": [
			":toBeContained()$0"
		],
		"description": "Compare the internal arguments by checking if first is contained in second, and chain on return.\n"
	},
	"pickle.adapt 042": {
		"prefix": "pickle.adapt:toBeLesserThan()",
		"body": [
			":toBeLesserThan()$0"
		],
		"description": "Compare the internal arguments by checking if first is lesser than second, and chain on return.\n"
	},
	"pickle.adapt 043": {
		"prefix": "pickle.adapt:toBeGreaterThan()",
		"body": [
			":toBeGreaterThan()$0"
		],
		"description": "Compare the internal arguments by checking if first is greater than second, and chain on return.\n"
	},
	"pickle.adapt 044": {
		"prefix": "pickle.adapt:toBeLesserOrEqual()",
		"body": [
			":toBeLesserOrEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is lesser or equal to second, and chain on return.\n"
	},
	"pickle.adapt 045": {
		"prefix": "pickle.adapt:toBeGreaterOrEqual()",
		"body": [
			":toBeGreaterOrEqual()$0"
		],
		"description": "Compare the internal arguments by checking if first is greater or equal to second, and chain on return.\n"
	},
	"pickle.adapt 046": {
		"prefix": "pickle.adapt:toBeMatch()",
		"body": [
			":toBeMatch()$0"
		],
		"description": "Compare the internal arguments by checking if first is a match in second, and chain on return.\n"
	},
	"pickle.adapt 047": {
		"prefix": "pickle.adapt:toBeUMatch()",
		"body": [
			":toBeUMatch()$0"
		],
		"description": "Compare the internal arguments by checking if first is a Unicode match in second, and chain on return.\n"
	},
	"pickle 001": {
		"prefix": "pickle.describe( arg[, ...] )",
		"body": [
			"return describe( ${1:arg${2:, ${3:...}} )$0"
		],
		"description": "Bootstrap pickle, create frame describe, add varargs, and chain on return.\n"
	},
	"pickle 002": {
		"prefix": "pickle.describe { subject }",
		"body": [
			"return describe { ${1:subject} }$0"
		],
		"description": "Bootstrap pickle, create frame describe, add subject, and chain on return.\n"
	},
	"pickle 003": {
		"prefix": "pickle.describe \"message\"",
		"body": [
			"return describe \"${1:message}\" $0"
		],
		"description": "Bootstrap pickle, create frame describe, add message, and chain on return.\n"
	},
	"pickle 004": {
		"prefix": "pickle.context( arg[, ...] )",
		"body": [
			"context( ${1:arg${2:, ${3:...}} )$0"
		],
		"description": "Create frame context, add varargs, and chain on return.\n"
	},
	"pickle 005": {
		"prefix": "pickle.context { subject }",
		"body": [
			"context { ${1:subject} }$0"
		],
		"description": "Create frame context, add subject, and chain on return.\n"
	},
	"pickle 006": {
		"prefix": "pickle.describe \"message\"",
		"body": [
			"context \"${1:message}\" $0"
		],
		"description": "Create frame context, add message, and chain on return.\n"
	},
	"pickle 007": {
		"prefix": "pickle.it( arg[, ...] )",
		"body": [
			"it( ${1:arg${2:, ${3:...}} )$0"
		],
		"description": "Create frame it, add varargs, and chain on return.\n"
	},
	"pickle 008": {
		"prefix": "pickle.it { subject }",
		"body": [
			"it { ${1:subject} }$0"
		],
		"description": "Create frame it, add subject, and chain on return.\n"
	},
	"pickle 009": {
		"prefix": "pickle.it \"message\"",
		"body": [
			"it \"${1:message}\" $0"
		],
		"description": "Create frame it, add message, and chain on return.\n"
	},
	"pickle 010": {
		"prefix": "pickle.frame { subject }",
		"body": [
			" { ${1:subject} } $0"
		],
		"description": "Add subject to current frame, and chain on return.\n"
	},
	"pickle 011": {
		"prefix": "pickle.frame \"message\"",
		"body": [
			" \"${1:message}\" $0"
		],
		"description": "Add message to current frame, and chain on return.\n"
	},
	"pickle 012": {
		"prefix": "pickle.frame (function() end)",
		"body": [
			" (function() $0 end)"
		],
		"description": "Add fixture to current frame, and chain on return.\n"
	},
	"pickle.spy 001": {
		"prefix": "pickle.carp( [str] )",
		"body": [
			"carp( ${1:str} )$0"
		],
		"description": "Warn called without exiting, with caller and arguments, and chain on return\n"
	},
	"pickle.spy 002": {
		"prefix": "pickle.cluck( [str] )",
		"body": [
			"cluck( ${1:str} )$0"
		],
		"description": "Warn called without exiting, with caller, arguments and stack trace, and chain on return\n"
	},
	"pickle.spy 003": {
		"prefix": "pickle.croak( [str] )",
		"body": [
			"croak( ${1:str} )$0"
		],
		"description": "Warn called with exit, with caller and arguments, and chain on return\n"
	},
	"pickle.spy 004": {
		"prefix": "pickle.confess( [str] )",
		"body": [
			"confess( ${1:str} )$0"
		],
		"description": "Warn called without exiting, with caller, arguments and stack trace, and chain on return\n"
	}
}