{
	"bit32 001": {
		"prefix": "bit32.band( ... )",
		"body": [
			"bit32.band( ${1:...} )$0"
		],
		"description": "Bitwise \"and\" of all arguments.\n"
	},
	"bit32 002": {
		"prefix": "bit32.bnot( ... )",
		"body": [
			"bit32.bnot( ${1:x} )$0"
		],
		"description": "Bitwise complement of argument.\n"
	},
	"bit32 003": {
		"prefix": "bit32.bor( ... )",
		"body": [
			"bit32.bor( ${1:...} )$0"
		],
		"description": "Bitwise \"or\" of all arguments.\n"
	},
	"bit32 004": {
		"prefix": "bit32.btest( ... )",
		"body": [
			"bit32.btest( ${1:...} )$0"
		],
		"description": "Bitwise \"and\" of all arguments followed by not equal to zero.\n"
	},
	"bit32 005": {
		"prefix": "bit32.bxor( ... )",
		"body": [
			"bit32.bxor( ${1:...} )$0"
		],
		"description": "Bitwise \"xor\" of all arguments.\n"
	},
	"bit32 006": {
		"prefix": "bit32.extract( n, field, width)",
		"body": [
			"bit32.extract( ${1:n}, ${2:field${3:, ${4:width}}} )$0"
		],
		"description": "Bitwise extract.\n"
	},
	"bit32 007": {
		"prefix": "bit32.replace( n, v, field, width)",
		"body": [
			"bit32.replace( ${1:n}, ${2:v}, ${3:field${4:, ${5:width}}} )$0"
		],
		"description": "Bitwise replace, "
	},
	"bit32 008": {
		"prefix": "bit32.lshift( n, disp )",
		"body": [
			"bit32.lshift( ${1:n}, ${2:disp} )$0"
		],
		"description": "Bitwise left shift.\n"
	},
	"bit32 009": {
		"prefix": "bit32.rshift( n, disp )",
		"body": [
			"bit32.rshift( ${1:n}, ${2:disp} )$0"
		],
		"description": "Bitwise right shift.\n"
	},
	"bit32 010": {
		"prefix": "bit32.arshift( n, disp )",
		"body": [
			"bit32.arshift( ${1:n}, ${2:disp} )$0"
		],
		"description": "Bitwise arithmetic shift.\n"
	},
	"bit32 011": {
		"prefix": "bit32.lrotate( n, disp )",
		"body": [
			"bit32.lrotate( ${1:n}, ${2:disp} )$0"
		],
		"description": "Bitwise left rotate.\n"
	},
	"bit32 012": {
		"prefix": "bit32.rrotate( n, disp )",
		"body": [
			"bit32.rrotate( ${1:n}, ${2:disp} )$0"
		],
		"description": "Bitwise right rotate.\n"
	},
	"frame 001": {
		"prefix": "args",
		"body": [
			"args"
		],
		"description": "Table for arguments passed to the frame."
	},
	"frame 002": {
		"prefix": "frame:callParserFunction( name, args )",
		"body": [
			"frame:callParserFunction( ${1:name}${2:, ${3:args}} )$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 003": {
		"prefix": "frame:callParserFunction( name, ... )",
		"body": [
			"frame:callParserFunction( ${1:name}${2:, ${3:...}} )$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 004": {
		"prefix": "frame:callParserFunction{ name = string, args = table }",
		"body": [
			"frame:callParserFunction{ name = ${1:string}, args = ${2:table} }$0"
		],
		"description": "Call a parser function, returning an appropriate string.\n"
	},
	"frame 005": {
		"prefix": "frame:expandTemplate{ name = string, args = table }",
		"body": [
			"frame:expandTemplate{ name = ${1:string}, args = ${2:table} }$0"
		],
		"description": "Transclude a template, returning an appropriate string.\n"
	},
	"frame 006": {
		"prefix": "frame:extensionTag( name, content, args )",
		"body": [
			"frame:extensionTag( ${1:name}${2:[, content]}${3:[, args]} )$0"
		],
		"description": "Call a tag function, returning an appropriate string.\n"
	},
	"frame 007": {
		"prefix": "frame:extensionTag{ name = string, content = string, args =table_or_string }",
		"body": [
			"frame:extensionTag{ name = ${1:string}, args = ${2:string}, args = ${3:table_or_string} }$0"
		],
		"description": "Call a tag function, returning an appropriate string.\n"
	},
	"frame 008": {
		"prefix": "frame:getParent()",
		"body": [
			"frame:getParent()$0"
		],
		"description": "Get the frame of the parent, in the \"invoke\" hierarchy.\n"
	},
	"frame 009": {
		"prefix": "frame:getTitle()",
		"body": [
			"frame:getTitle()$0"
		],
		"description": "Get the title as a string of the frame.\n"
	},
	"frame 010": {
		"prefix": "frame:newChild{ title = title, args = table }",
		"body": [
			"frame:newChild{ title = ${1:title}, args = ${2:table} }$0"
		],
		"description": "Create a new child of the current frame.\n"
	},
	"frame 011": {
		"prefix": "frame:preprocess( string )",
		"body": [
			"frame:preprocess( ${1:string} )$0"
		],
		"description": "Expand the string in the context of the frame.\n"
	},
	"frame 012": {
		"prefix": "frame:preprocess{ text = string }",
		"body": [
			"frame:preprocess{ text = ${1:string} }$0"
		],
		"description": "Expand the string in the context of the frame.\n"
	},
	"frame 013": {
		"prefix": "frame:getArgument( arg )",
		"body": [
			"frame:getArgument( ${1:arg} )$0"
		],
		"description": "Gets an object for the specified argument, or nil if the argument is not provided.\n"
	},
	"frame 014": {
		"prefix": "frame:getArgument{ name = arg }",
		"body": [
			"frame:getArgument{ name = ${1:arg} }$0"
		],
		"description": "Gets an object for the specified argument, or nil if the argument is not provided.\n"
	},
	"frame 015": {
		"prefix": "frame:newParserValue( text )",
		"body": [
			"frame:newParserValue( ${1:text} )$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 016": {
		"prefix": "frame:newParserValue( text = text )",
		"body": [
			"frame:newParserValue{ text = ${1:text} }$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 017": {
		"prefix": "frame:newTemplateParserValue{ title = title, args = table }",
		"body": [
			"frame:newTemplateParserValue{ title = ${1:title}, args = ${2:table} }$0"
		],
		"description": "Returns an object with a method :expand(), that returns :preprocess( text ).\n"
	},
	"frame 018": {
		"prefix": "frame:argumentPairs()",
		"body": [
			"frame:argumentPairs()$0"
		],
		"description": "Same as pairs( frame.args )\n"
	},
	"mw.hash 001": {
		"prefix": "mw.hash.hashValue( algo, value )",
		"body": [
			"mw.hash.hashValue( ${1:algo}, ${2:value} )$0"
		],
		"description": "Hashes a string value with the specified algorithm.\n"
	},
	"mw.hash 002": {
		"prefix": "mw.hash.listAlgorithms()",
		"body": [
			"mw.hash.listAlgorithms()$0"
		],
		"description": "Returns a list of supported hashing algorithms.\n"
	},
	"mw.html 001": {
		"prefix": "mw.html.create( tagName, args )",
		"body": [
			"mw.html.create( ${1:tagName${2:, ${3:args}}} )$0"
		],
		"description": "Creates a new instance with the given tag.\n"
	},
	"mw.html 002": {
		"prefix": "mw.html:node( builder )",
		"body": [
			":node( ${1:builder} )$0"
		],
		"description": "Appends a child to the current node.\n"
	},
	"mw.html 003": {
		"prefix": "mw.html:wikitext( ... )",
		"body": [
			":wikitext( ${1:...} )$0"
		],
		"description": "Appends wikitext strings to the current node.\n"
	},
	"mw.html 004": {
		"prefix": "mw.html:newline()",
		"body": [
			":newline()$0"
		],
		"description": "Appends a newline to the current node.\n"
	},
	"mw.html 005": {
		"prefix": "mw.html:tag( tagName, args )",
		"body": [
			":tag( ${1:tagName}, ${2:args} )$0"
		],
		"description": "Appends a new child node with the given tag to the current node.\n"
	},
	"mw.html 006": {
		"prefix": "mw.html:attr( name, value )",
		"body": [
			":attr( ${1:name}, ${2:value} )$0"
		],
		"description": "Set a html attribute with the given name and value on the current node.\n"
	},
	"mw.html 007": {
		"prefix": "mw.html:attr( table )",
		"body": [
			":attr( ${1:table} )$0"
		],
		"description": "Set html attributes with the given name and value on the current node.\n"
	},
	"mw.html 008": {
		"prefix": "mw.html:getAttr( name )",
		"body": [
			":getAttr( ${1:name} )$0"
		],
		"description": "Get the value of a html attribute previously set on the current node.\n"
	},
	"mw.html 009": {
		"prefix": "mw.html:addClass( class )",
		"body": [
			":addClass( ${1:class} )$0"
		],
		"description": "Adds the class name to the current node.\n"
	},
	"mw.html 010": {
		"prefix": "mw.html:css( name, value )",
		"body": [
			":css( ${1:name}, ${2:value} )$0"
		],
		"description": "Set a css property with the given name and value on the current node.\n"
	},
	"mw.html 011": {
		"prefix": "mw.html:css( table )",
		"body": [
			":css( ${1:table} )$0"
		],
		"description": "Set css properties with the given name and value on the current node.\n"
	},
	"mw.html 012": {
		"prefix": "mw.html:cssText( css )",
		"body": [
			":cssText( ${1:css} )$0"
		],
		"description": "Add raw css to the style attribute on the current node.\n"
	},
	"mw.html 013": {
		"prefix": "mw.html:done()",
		"body": [
			":done()$0"
		],
		"description": "Returns the parent node under which the current node was created.\n"
	},
	"mw.html 014": {
		"prefix": "mw.html:allDone()",
		"body": [
			":allDone()$0"
		],
		"description": "Returns the root node under which the current node was created."
	},
	"mw.language 001": {
		"prefix": "mw.language.fetchLanguageName( code, inLanguage )",
		"body": [
			"mw.language.fetchLanguageName( ${1:code}, ${2:inLanguage} )$0"
		],
		"description": "The full name of the language for the given language code.\n"
	},
	"mw.language 002": {
		"prefix": "mw.language.fetchLanguageNames( inLanguage, include )",
		"body": [
			"mw.language.fetchLanguageNames( ${1:inLanguage${2:, ${3:include}}} )$0"
		],
		"description": "Fetch the list of known languages.\n"
	},
	"mw.language 003": {
		"prefix": "mw.language.getContentLanguage()",
		"body": [
			"mw.language.getContentLanguage()$0"
		],
		"description": "Returns a language object for the default content language.\n"
	},
	"mw.language 004": {
		"prefix": "mw.language.getContentLanguage()",
		"body": [
			"mw.getContentLanguage()$0"
		],
		"description": "Returns a language object for the default content language.\n"
	},
	"mw.language 005": {
		"prefix": "mw.language.getFallbacksFor( code )",
		"body": [
			"mw.language.getFallbacksFor( ${1:code} )$0"
		],
		"description": "Returns a list of fallback language codes for the given code.\n"
	},
	"mw.language 006": {
		"prefix": "mw.language.isKnownLanguageTag( code )",
		"body": [
			"mw.language.isKnownLanguageTag( ${1:code} )$0"
		],
		"description": "Checks whether language code is a valid built-in code with known denomyn.\n"
	},
	"mw.language 007": {
		"prefix": "mw.language.isSupportedLanguage( code )",
		"body": [
			"mw.language.isSupportedLanguage( ${1:code} )$0"
		],
		"description": "Checks whether localisation is available for the language code.\n"
	},
	"mw.language 008": {
		"prefix": "mw.language.isValidBuiltInCode( code )",
		"body": [
			"mw.language.isValidBuiltInCode( ${1:code} )$0"
		],
		"description": "Checks whether the language code is valid for internal customisation.\n"
	},
	"mw.language 009": {
		"prefix": "mw.language.isValidCode( code )",
		"body": [
			"mw.language.isValidCode( ${1:code} )$0"
		],
		"description": "Checks whether the language code is superficially valid.\n"
	},
	"mw.language 010": {
		"prefix": "mw.language.new( code )",
		"body": [
			"mw.language.new( ${1:code} )$0"
		],
		"description": "Creates a new language object."
	},
	"mw.language 011": {
		"prefix": "mw.getLanguage( code )",
		"body": [
			"mw.getLanguage( ${1:code} )$0"
		],
		"description": "Creates a new language object."
	},
	"mw.language 012": {
		"prefix": "mw.language:getCode()",
		"body": [
			":getCode()$0"
		],
		"description": "Get the language code for the current language object.\n"
	},
	"mw.language 013": {
		"prefix": "mw.language:getFallbackLanguages()",
		"body": [
			":getFallbackLanguages()$0"
		],
		"description": "Get a list of language fallback codes for the current language object.\n"
	},
	"mw.language 014": {
		"prefix": "mw.language:isRTL()",
		"body": [
			":isRTL()$0"
		],
		"description": "Checks whether the language code is right-to-left.\n"
	},
	"mw.language 015": {
		"prefix": "mw.language:lc( s )",
		"body": [
			":lc( ${1:s} )$0"
		],
		"description": "Converts the whole string to lowercase.\n"
	},
	"mw.language 016": {
		"prefix": "mw.language:lcfirst( s )",
		"body": [
			":lcfirst( ${1:s} )$0"
		],
		"description": "Converts the first char in the string to lowercase.\n"
	},
	"mw.language 017": {
		"prefix": "mw.language:uc( s )",
		"body": [
			":uc( ${1:s} )$0"
		],
		"description": "Converts the whole string to uppercase.\n"
	},
	"mw.language 018": {
		"prefix": "mw.language:ucfirst( s )",
		"body": [
			":ucfirst( ${1:s} )$0"
		],
		"description": "Converts the first char in the string to uppercase.\n"
	},
	"mw.language 019": {
		"prefix": "mw.language:caseFold( s )",
		"body": [
			":caseFold( ${1:s} )$0"
		],
		"description": "Converts the string for case-insensitive comparison.\n"
	},
	"mw.language 020": {
		"prefix": "mw.language:formatNum( n, options )",
		"body": [
			":formatNum( ${1:n${2:, ${3:options}}} )$0"
		],
		"description": "Formats a number according to rules for the given language.\n"
	},
	"mw.language 021": {
		"prefix": "mw.language:formatDate( format, timestamp[, local] )",
		"body": [
			":formatDate( ${1:format}, ${2:timestamp${3:, ${4:local}}} )$0"
		],
		"description": "Formats a date according to rules for the given language.\n"
	},
	"mw.language 022": {
		"prefix": "mw.language:formatDuration( seconds[, allowedIntervals] )",
		"body": [
			":formatDuration( ${1:seconds${2:, ${3:allowedIntervals}}} )$0"
		],
		"description": "Formats a duration according to rules for the given language.\n"
	},
	"mw.language 023": {
		"prefix": "mw.language:parseFormattedNumber( s )",
		"body": [
			":parseFormattedNumber( ${1:s} )$0"
		],
		"description": "Inverts a formatted number in a given language into its source form.\n"
	},
	"mw.language 024": {
		"prefix": "mw.language:convertPlural( n, ... )",
		"body": [
			":convertPlural( ${1:n}, ${2:...} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 025": {
		"prefix": "mw.language:convertPlural( n, forms )",
		"body": [
			":convertPlural( ${1:n}, ${2:forms} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 026": {
		"prefix": "mw.language:plural( n, ... )",
		"body": [
			":plural( ${1:n}, ${2:...} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 027": {
		"prefix": "mw.language:plural( n, forms )",
		"body": [
			":plural( ${1:n}, ${2:forms} )$0"
		],
		"description": "Choose the appropriate grammatical form given the language.\n"
	},
	"mw.language 028": {
		"prefix": "mw.language:convertGrammar( word, case )",
		"body": [
			":convertGrammar( ${1:word}, ${2:case} )$0"
		],
		"description": "Choose the appropriate inflection given the language.\n"
	},
	"mw.language 029": {
		"prefix": "mw.language:grammar( case, word )",
		"body": [
			":grammar( ${1:word}, ${2:case} )$0"
		],
		"description": "Choose the appropriate inflection given the language.\n"
	},
	"mw.language 030": {
		"prefix": "mw.language:gender( what, masculine, feminine, neutral )",
		"body": [
			":gender( ${1:what}, ${2:masculine}, ${3:feminine}, ${4:neutral} )$0"
		],
		"description": "Choose the appropriate gender form given the language.\n"
	},
	"mw.language 031": {
		"prefix": "mw.language:gender( what, { masculine, feminine, neutral } )",
		"body": [
			":gender( ${1:what}, { ${2:masculine}, ${3:feminine}, ${4:neutral} } )$0"
		],
		"description": "Choose the appropriate gender form given the language.\n"
	},
	"mw.language 032": {
		"prefix": "mw.language:getArrow( direction )",
		"body": [
			":getArrow( ${1:direction} )$0"
		],
		"description": "Get a Unicode arrow character corresponding to direction given the language.\n"
	},
	"mw.language 033": {
		"prefix": "mw.language:getDir()",
		"body": [
			":getDir()$0"
		],
		"description": "Get the Unicode direction mark given the language.\n"
	},
	"mw.language 034": {
		"prefix": "mw.language:getDirMark( opposite )",
		"body": [
			":getDirMark( ${1:opposite} )$0"
		],
		"description": "Get the Unicode direction mark corresponding to opposite given the language.\n"
	},
	"mw.language 035": {
		"prefix": "mw.language:getDirMarkEntity( opposite )",
		"body": [
			":getDirMarkEntity( ${1:opposite} )$0"
		],
		"description": "mw.language:getDirMarkEntity( opposite )\n opposite - boolean for inverting direction"
	},
	"mw.language 036": {
		"prefix": "mw.language:getDurationIntervals( seconds )",
		"body": [
			":getDurationIntervals( ${1:seconds} )$0"
		],
		"description": "Divides a duration according to rules for the given language.\n"
	},
	"mw.language 037": {
		"prefix": "mw.language:getDurationIntervals( seconds, allowedIntervals )",
		"body": [
			":getDurationIntervals( ${1:seconds${2:, ${3:allowedIntervals}}} )$0"
		],
		"description": "Divides a duration according to rules for the given language.\n"
	},
	"util 001": {
		"prefix": "libraryUtil.checkType( name, argIdx, arg, expectType, nilOk )",
		"body": [
			"libraryUtil.checkType( ${1:name}, ${2:argIdx}, ${3:arg}, ${4:expectType}, ${5:nilOk} )$0"
		],
		"description": "Check type and raise exception on wrong type.\n"
	},
	"util 002": {
		"prefix": "libraryUtil.checkTypeMulti( name, argIdx, arg, expectTypes )",
		"body": [
			"libraryUtil.checkTypeMulti( ${1:name}, ${2:argIdx}, ${3:arg}, ${4:expectTypes} )$0"
		],
		"description": "Check types and raise exception if type is not listed.\n"
	},
	"util 003": {
		"prefix": "libraryUtil.checkTypeForIndex( index, value, expectType )",
		"body": [
			"libraryUtil.checkTypeForIndex( ${1:index}, ${2:value}, ${3:expectType} )$0"
		],
		"description": "Raises an error if type of value does not match.\n"
	},
	"util 004": {
		"prefix": "libraryUtil.checkTypeForNamedArg( name, argName, arg, expectType, nilOk )",
		"body": [
			"libraryUtil.checkTypeForNamedArg( ${1:name}, ${2:argName}, ${3:arg}, ${4:expectType}, ${5:nilOk} )$0"
		],
		"description": "Raises an error if type of arg does not match.\n"
	},
	"util 005": {
		"prefix": "makeCheckSelfFunction( libraryName, varName, selfObj, selfObjDesc )",
		"body": [
			"makeCheckSelfFunction( ${1:libraryName}, ${2:varName}, ${3:selfObj}, ${4:selfObjDesc} )$0"
		],
		"description": "Returns a function for self-tests.\n"
	},
	"mw 001": {
		"prefix": "mw.addWarning( text )",
		"body": [
			"mw.addWarning( ${1:text} )$0"
		],
		"description": "Adds a warning above the preview during editing.\n"
	},
	"mw 002": {
		"prefix": "mw.allToString( ... )",
		"body": [
			"mw.allToString( ${1:...} )$0"
		],
		"description": "Calls tostring() on all arguments and concatenates them.\n"
	},
	"mw 003": {
		"prefix": "mw.clone( value )",
		"body": [
			"mw.clone( ${1:value} )$0"
		],
		"description": "Creates a deep copy of a value.\n"
	},
	"mw 004": {
		"prefix": "mw.getCurrentFrame()",
		"body": [
			"mw.getCurrentFrame()$0"
		],
		"description": "Get the current frame object.\n"
	},
	"mw 005": {
		"prefix": "mw.incrementExpensiveFunctionCount()",
		"body": [
			"mw.incrementExpensiveFunctionCount()$0"
		],
		"description": "Adds one to the count, and throws an exception when overflowing.\n"
	},
	"mw 006": {
		"prefix": "mw.isSubsting()",
		"body": [
			"mw.isSubsting()$0"
		],
		"description": "Checks if last invoke is substed.\n"
	},
	"mw 007": {
		"prefix": "mw.loadData( module )",
		"body": [
			"mw.loadData( ${1:module} )$0"
		],
		"description": "Loads data from a separate page.\n"
	},
	"mw 008": {
		"prefix": "mw.dumpObject( object )",
		"body": [
			"mw.dumpObject( ${1:object} )$0"
		],
		"description": "Serializes object to a human-readable representation.\n"
	},
	"mw 009": {
		"prefix": "mw.log( ... )",
		"body": [
			"mw.log( ${1:...} )$0"
		],
		"description": "Surface serialize and appends the result to the log buffer.\n"
	},
	"mw 010": {
		"prefix": "mw.logObject ( object, prefix )",
		"body": [
			"mw.logObject( ${1:object${2:, ${3:prefix}}} )$0"
		],
		"description": "Serializes object to a human-readable representation and appends the result to the log buffer.\n"
	},
	"string 001": {
		"prefix": "string.byte( s[, i[, j]] )",
		"body": [
			"string.byte( ${1:s${2:, ${3:i${4:, ${5:j}}}} )$0"
		],
		"description": "Returns the string as an array of bytes.\n"
	},
	"string 002": {
		"prefix": "string.char( ... )",
		"body": [
			"string.char( ${1:...} )$0"
		],
		"description": "Returns the arguments as a string of chars.\n"
	},
	"string 003": {
		"prefix": "string.find( s, pattern[, init[, plain]] )",
		"body": [
			"string.find( ${1:s}, ${2:pattern${3:, ${4:init${5:, ${6:plain}}}}} )$0"
		],
		"description": "Search for the first occurence of pattern within the string.\n"
	},
	"string 004": {
		"prefix": "string.format( format[, ...] )",
		"body": [
			"string.format( ${1:format${2:, ${3:...}}} )$0"
		],
		"description": "Formats the string, and injects optional arguments.\n"
	},
	"string 005": {
		"prefix": "string.gmatch( s, pattern )",
		"body": [
			"string.gmatch( ${1:s}, ${2:pattern} )$0"
		],
		"description": "Creates an iterator for the captures from the given arguments.\n"
	},
	"string 006": {
		"prefix": "string.gsub( s, pattern, repl[, n] )",
		"body": [
			"string.gsub( ${1:s}, ${2:pattern}, ${3:repl${4:, ${5:n}}} )$0"
		],
		"description": "Returns the string with occurences of patterns replaced.\n"
	},
	"string 007": {
		"prefix": "string.len( s )",
		"body": [
			"string.len(${1:s} )$0"
		],
		"description": "Calculates the length of the string in bytes.\n"
	},
	"string 008": {
		"prefix": "string.lower( s )",
		"body": [
			"string.lower( ${1:s} )$0"
		],
		"description": "Change all ascii uppercase letters to lowercase.\n"
	},
	"string 009": {
		"prefix": "string.match( s, pattern[, init] )",
		"body": [
			"string.match( ${1:s}, ${2:pattern${3:, ${4:init}} )$0"
		],
		"description": "Returns the first part matched by pattern.\n"
	},
	"string 010": {
		"prefix": "string.rep( s, n )",
		"body": [
			"string.rep( ${1:s}, ${2:n} )$0"
		],
		"description": "Returns a string with n copies of s.\n"
	},
	"string 011": {
		"prefix": "string.reverse( s )",
		"body": [
			"string.reverse( ${1:s} )$0"
		],
		"description": "Returns the string of chars in reverse byte order.\n"
	},
	"string 012": {
		"prefix": "string.sub( s, i[, j] )",
		"body": [
			"string.sub( ${1:s}, ${2:i${3:, ${4:j}} )$0"
		],
		"description": "Returns the part given by the arguments.\n"
	},
	"string 013": {
		"prefix": "string.upper( s )",
		"body": [
			"string.upper( ${1:s} )$0"
		],
		"description": "Change all ascii lowercase letters to uppercase.\n"
	},
	"mw.uri 001 ": {
		"prefix": "mw.uri.encode( s[, enctype] )",
		"body": [
			"mw.uri.encode( ${1:s${2:, ${3:enctype}}} )$0"
		],
		"description": "Percent-encodes the string.\n"
	},
	"mw.uri 002 ": {
		"prefix": "mw.uri.decode( s[, enctype] )",
		"body": [
			"mw.uri.decode( ${1:s${2:, ${3:enctype}}} )$0"
		],
		"description": "Percent-decodes the string.\n"
	},
	"mw.uri 003 ": {
		"prefix": "mw.uri.anchorEncode( s )",
		"body": [
			"mw.uri.anchorEncode( ${1:s} )$0"
		],
		"description": "Encodes the string for use in a uri fragment.\n"
	},
	"mw.uri 004 ": {
		"prefix": "mw.uri.buildQueryString( table )",
		"body": [
			"mw.uri.buildQueryString( ${1:table} )$0"
		],
		"description": "Encodes the table as a uri query string.\n"
	},
	"mw.uri 005 ": {
		"prefix": "mw.uri.parseQueryString( s, i, j )",
		"body": [
			"mw.uri.parseQueryString( ${1:s}, ${2:i}, ${3:j} )$0"
		],
		"description": "Decodes the query string s to a table.\n"
	},
	"mw.uri 006 ": {
		"prefix": "mw.uri.canonicalUrl( page[, query] )",
		"body": [
			"mw.uri.canonicalUrl( ${1:page${2:, ${3:query}}} )$0"
		],
		"description": "Returns a uri for the canonical url, with optional query string/table.\n"
	},
	"mw.uri 007 ": {
		"prefix": "mw.uri.fullUrl( page[, query] )",
		"body": [
			"mw.uri.fullUrl( ${1:page${2:, ${3:query}}} )$0"
		],
		"description": "Returns a uri for the full url, with optional query string/table.\n"
	},
	"mw.uri 008 ": {
		"prefix": "mw.uri.localUrl(  page[, query] )",
		"body": [
			"mw.uri.localUrl( ${1:page${2:, ${3:query}}} )$0"
		],
		"description": "Returns a uri for the full url, with optional query string/table.\n"
	},
	"mw.uri 009 ": {
		"prefix": "mw.uri.new( s )",
		"body": [
			"mw.uri.new( ${1:s} )$0"
		],
		"description": "Constructs a new uri object for the passed string or table.\n"
	},
	"mw.uri 010 ": {
		"prefix": "mw.uri.validate( table )",
		"body": [
			"mw.uri.validate( ${1:table} )$0"
		],
		"description": "Validates the passed table or uri object.\n"
	},
	"mw.uri 011 ": {
		"prefix": "mw.uri:parse( s )",
		"body": [
			":parse( ${1:s} )$0"
		],
		"description": "Parses a string into the current uri object.\n"
	},
	"mw.uri 012 ": {
		"prefix": "mw.uri:clone()",
		"body": [
			":clone()$0"
		],
		"description": "Makes a copy of the URI object.\n"
	},
	"mw.uri 013 ": {
		"prefix": "mw.uri:extend( parameters )",
		"body": [
			":extend( ${1:parameters} )$0"
		],
		"description": "Merges the parameters into the object's query table.\n"
	},
	"mw.ustring 001": {
		"prefix": "mw.ustring.maxPatternLength",
		"body": [
			"mw.ustring.maxPatternLength$0"
		],
		"description": "The maximum allowed length of a pattern, in bytes.\n"
	},
	"mw.ustring 002": {
		"prefix": "mw.ustring.maxStringLength",
		"body": [
			"mw.ustring.maxPatternLength$0"
		],
		"description": "The maximum allowed length of a ustring, in bytes.\n"
	},
	"mw.ustring 003": {
		"prefix": "mw.ustring.byte( s[, i[, j]] )",
		"body": [
			"mw.ustring.byte( ${1:s${2:, ${3:i${4:, ${5:j}}}}} )$0"
		],
		"description": "Returns the ustring as an array of bytes.\n"
	},
	"mw.ustring 004": {
		"prefix": "mw.ustring.byteoffset( s[, l[, i]] )",
		"body": [
			"mw.ustring.byteoffset( ${1:s${2:, ${3:l${4:, ${5:i}}}}} )$0"
		],
		"description": "Returns the byte offset of a character in the ustring.\n"
	},
	"mw.ustring 005": {
		"prefix": "mw.ustring.char( ... )",
		"body": [
			"mw.ustring.char( ${1:...} )$0"
		],
		"description": "Returns the arguments as a ustring of chars.\n"
	},
	"mw.ustring 006": {
		"prefix": "mw.ustring.codepoint( s[, i[, j]] )",
		"body": [
			"mw.ustring.codepoint( ${1:s${2:, ${3:i${4:, ${5:j}}}}} )$0"
		],
		"description": "Returns the ustring as an array of codepoints.\n"
	},
	"mw.ustring 007": {
		"prefix": "mw.ustring.find( s, pattern[, init[, plain]] )",
		"body": [
			"mw.ustring.find( ${1:s}, ${2:pattern${3:, ${4:init${5:, ${6:plain}}}}} )$0"
		],
		"description": "Search for the first occurence of pattern within the ustring.\n"
	},
	"mw.ustring 008": {
		"prefix": "mw.ustring.format( format[, ...] )",
		"body": [
			"mw.ustring.format( ${1:format${2:, ${3:...}}} )$0"
		],
		"description": "Formats the ustring, and injects optional arguments.\n"
	},
	"mw.ustring 009": {
		"prefix": "mw.ustring.gcodepoint( s[, i[, j]] )",
		"body": [
			"mw.ustring.gcodepoint( ${1:s${2:, ${3:i${4:, ${5:j}}}}} )$0"
		],
		"description": "Creates an iterator for the codepoints from the given arguments.\n"
	},
	"mw.ustring 010": {
		"prefix": "mw.ustring.gmatch( s, pattern )",
		"body": [
			"mw.ustring.gmatch( ${1:s}, ${2:pattern} )$0"
		],
		"description": "Creates an iterator for the captures from the given arguments.\n"
	},
	"mw.ustring 011": {
		"prefix": "mw.ustring.gsub( s, pattern, repl[, n] )",
		"body": [
			"mw.ustring.gsub(${1:s}, ${2:pattern}, ${3:repl${4:, ${5:n}}} )$0"
		],
		"description": "Returns the ustring with occurences of patterns replaced.\n"
	},
	"mw.ustring 012": {
		"prefix": "mw.ustring.isutf8( s )",
		"body": [
			"mw.ustring.isutf8( ${1:s} )$0"
		],
		"description": "Checks whether the ustring is valid UTF-8.\n"
	},
	"mw.ustring 013": {
		"prefix": "mw.ustring.len( s )",
		"body": [
			"mw.ustring.len( ${1:s} )$0"
		],
		"description": "Calculates the length of the string in bytes.\n"
	},
	"mw.ustring 014": {
		"prefix": "mw.ustring.lower( s )",
		"body": [
			"mw.ustring.lower( ${1:s} )$0"
		],
		"description": "Change all unicode uppercase letters to lowercase.\n"
	},
	"mw.ustring 015": {
		"prefix": "mw.ustring.match( s, pattern[, init] )",
		"body": [
			"mw.ustring.match( ${1:s}, ${2:pattern${3:, ${4:init}}} )$0"
		],
		"description": "Returns the first part matched by pattern.\n"
	},
	"mw.ustring 016": {
		"prefix": "mw.ustring.rep( s, n )",
		"body": [
			"mw.ustring.rep( ${1:s}, ${2:n} )$0"
		],
		"description": "Returns a string with n copies of s.\n"
	},
	"mw.ustring 017": {
		"prefix": "mw.ustring.sub( s, i[, j] )",
		"body": [
			"mw.ustring.sub( ${1:s}, ${2:i${3:, ${4:j}}} )$0"
		],
		"description": "Returns the part given by the arguments.\n"
	},
	"mw.ustring 018": {
		"prefix": "mw.ustring.toNFC( s )",
		"body": [
			"mw.ustring.toNFC( ${1:s} )$0"
		],
		"description": "Converts the string to Normalization Form C.\n"
	},
	"mw.ustring 019": {
		"prefix": "mw.ustring.toNFD( s )",
		"body": [
			"mw.ustring.toNFD( ${1:s} )$0"
		],
		"description": "Converts the string to Normalization Form D.\n"
	},
	"mw.ustring 020": {
		"prefix": "mw.ustring.upper( s )",
		"body": [
			"mw.ustring.upper( ${1:s} )$0"
		],
		"description": "Change all unicode lowercase letters to uppercase.\n"
	}
}